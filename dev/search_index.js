var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page provides documentation for all public functions and types in OpenStreetMapIO.jl.","category":"page"},{"location":"api/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api/#File-Reading","page":"API Reference","title":"File Reading","text":"","category":"section"},{"location":"api/#OpenStreetMapIO.readpbf","page":"API Reference","title":"OpenStreetMapIO.readpbf","text":"readpbf(filename; node_callback, way_callback, relation_callback)\n\nRead OpenStreetMap data from a PBF (Protocol Buffer Format) file.\n\nArguments\n\nfilename::String: Path to the PBF file to read\n\nKeyword Arguments\n\nnode_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering nodes\nway_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering ways\nrelation_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering relations\n\nCallback Functions\n\nCallback functions should accept one argument of the respective type (Node, Way, or Relation) and return either:\n\nAn object of the same type (element will be included in the result)\nnothing (element will be excluded from the result)\n\nReturns\n\nOpenStreetMap: Complete OSM dataset with nodes, ways, relations, and metadata\n\nExamples\n\n# Read all data\nosmdata = readpbf(\"map.pbf\")\n\n# Filter to only include restaurants\nfunction keep_restaurants(node)\n    if node.tags !== nothing && haskey(node.tags, \"amenity\") && node.tags[\"amenity\"] == \"restaurant\"\n        return node\n    end\n    return nothing\nend\nosmdata = readpbf(\"map.pbf\", node_callback=keep_restaurants)\n\n# Filter multiple element types\nosmdata = readpbf(\"map.pbf\",\n    node_callback=keep_restaurants,\n    way_callback=way -> way.tags !== nothing && haskey(way.tags, \"highway\") ? way : nothing\n)\n\nSee Also\n\nreadosm: Read OSM XML files\nqueryoverpass: Query data from Overpass API\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenStreetMapIO.readosm","page":"API Reference","title":"OpenStreetMapIO.readosm","text":"readosm(filename; node_callback, way_callback, relation_callback)\n\nRead OpenStreetMap data from an XML file.\n\nArguments\n\nfilename::String: Path to the OSM XML file to read\n\nKeyword Arguments\n\nnode_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering nodes\nway_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering ways\nrelation_callback::Union{Function,Nothing}=nothing: Optional callback function for filtering relations\n\nCallback Functions\n\nCallback functions should accept one argument of the respective type (Node, Way, or Relation) and return either:\n\nAn object of the same type (element will be included in the result)\nnothing (element will be excluded from the result)\n\nReturns\n\nOpenStreetMap: Complete OSM dataset with nodes, ways, relations, and metadata\n\nExamples\n\n# Read all data\nosmdata = readosm(\"map.osm\")\n\n# Filter to only include restaurants\nfunction keep_restaurants(node)\n    if node.tags !== nothing && haskey(node.tags, \"amenity\") && node.tags[\"amenity\"] == \"restaurant\"\n        return node\n    end\n    return nothing\nend\nosmdata = readosm(\"map.osm\", node_callback=keep_restaurants)\n\nSee Also\n\nreadpbf: Read OSM PBF files\nqueryoverpass: Query data from Overpass API\n\n\n\n\n\n","category":"function"},{"location":"api/#Online-Queries","page":"API Reference","title":"Online Queries","text":"","category":"section"},{"location":"api/#OpenStreetMapIO.queryoverpass","page":"API Reference","title":"OpenStreetMapIO.queryoverpass","text":"queryoverpass(bbox; kwargs...)\n\nQuery OpenStreetMap data from Overpass API using a bounding box.\n\nArguments\n\nbbox::BBox: Geographic bounding box to query\n\nKeyword Arguments\n\ntimeout::Int64=25: Query timeout in seconds\n\nReturns\n\nOpenStreetMap: OSM data within the specified bounding box\n\nExamples\n\nbbox = BBox(54.0, 9.0, 55.0, 10.0)\nosmdata = queryoverpass(bbox)\n\n\n\n\n\nqueryoverpass(position, radius; kwargs...)\n\nQuery OpenStreetMap data from Overpass API using a center point and radius.\n\nArguments\n\nposition::Position: Center point for the query\nradius::Real: Radius in meters around the center point\n\nKeyword Arguments\n\ntimeout::Int64=25: Query timeout in seconds\n\nReturns\n\nOpenStreetMap: OSM data within the specified radius\n\nExamples\n\ncenter = Position(54.2619665, 9.9854149)\nosmdata = queryoverpass(center, 1000)  # 1km radius\n\n\n\n\n\nqueryoverpass(bounds; timeout)\n\nQuery OpenStreetMap data from Overpass API using a bounds string.\n\nArguments\n\nbounds::String: Bounds string in Overpass API format (e.g., \"54.0,9.0,55.0,10.0\" or \"around:1000,54.0,9.0\")\n\nKeyword Arguments\n\ntimeout::Int64=25: Query timeout in seconds\n\nReturns\n\nOpenStreetMap: OSM data matching the query\n\nExamples\n\n# Bounding box query\nosmdata = queryoverpass(\"54.0,9.0,55.0,10.0\")\n\n# Radius query\nosmdata = queryoverpass(\"around:1000,54.2619665,9.9854149\")\n\nSee Also\n\nreadpbf: Read OSM PBF files\nreadosm: Read OSM XML files\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Types","page":"API Reference","title":"Data Types","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#OpenStreetMapIO.OpenStreetMap","page":"API Reference","title":"OpenStreetMapIO.OpenStreetMap","text":"OpenStreetMap\n\nContainer for complete OpenStreetMap data including nodes, ways, relations, and metadata.\n\nFields\n\nnodes::Dict{Int64,Node}: Dictionary mapping node IDs to Node objects\nways::Dict{Int64,Way}: Dictionary mapping way IDs to Way objects\nrelations::Dict{Int64,Relation}: Dictionary mapping relation IDs to Relation objects\nmeta::Dict{String,Any}: Metadata about the dataset (bounding box, timestamps, etc.)\n\nConstructors\n\nOpenStreetMap(): Create empty OpenStreetMap object\nOpenStreetMap(nodes, ways, relations, meta): Create with pre-populated data\n\nExamples\n\nosmdata = OpenStreetMap()\nosmdata = readpbf(\"map.pbf\")  # Load from file\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.Node","page":"API Reference","title":"OpenStreetMapIO.Node","text":"Node\n\nRepresents an OpenStreetMap node (point) with geographic coordinates and optional tags.\n\nFields\n\nposition::Position: Geographic coordinates of the node\ntags::Union{Dict{String,String},Nothing}: Key-value pairs describing the node, or nothing if no tags\ninfo::Union{Info,Nothing}: Optional metadata (version, timestamp, changeset, user, etc.)\n\nExamples\n\nnode = Node(Position(54.2619665, 9.9854149), Dict(\"amenity\" => \"restaurant\"), nothing)\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.Way","page":"API Reference","title":"OpenStreetMapIO.Way","text":"Way\n\nRepresents an OpenStreetMap way (path) as an ordered list of node references.\n\nFields\n\nrefs::Vector{Int64}: Ordered list of node IDs that form the way\ntags::Union{Dict{String,String},Nothing}: Key-value pairs describing the way, or nothing if no tags\ninfo::Union{Info,Nothing}: Optional metadata (version, timestamp, changeset, user, etc.)\npositions::Union{Vector{Position},Nothing}: Optional node locations (LocationsOnWays feature)\n\nExamples\n\nway = Way([12345, 67890, 11111], Dict(\"highway\" => \"primary\"), nothing, nothing)\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.Relation","page":"API Reference","title":"OpenStreetMapIO.Relation","text":"Relation\n\nRepresents an OpenStreetMap relation (grouping) of nodes, ways, and other relations.\n\nFields\n\nrefs::Vector{Int64}: List of element IDs that are members of this relation\ntypes::Vector{String}: Types of each member (\"node\", \"way\", or \"relation\")\nroles::Vector{String}: Roles of each member in the relation\ntags::Union{Dict{String,String},Nothing}: Key-value pairs describing the relation, or nothing if no tags\ninfo::Union{Info,Nothing}: Optional metadata (version, timestamp, changeset, user, etc.)\n\nExamples\n\nrelation = Relation([12345, 67890], [\"node\", \"way\"], [\"stop\", \"platform\"], Dict(\"route\" => \"bus\"), nothing)\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.BBox","page":"API Reference","title":"OpenStreetMapIO.BBox","text":"BBox\n\nRepresents a geographic bounding box with latitude and longitude boundaries.\n\nFields\n\nbottom_lat::Float64: Minimum latitude (southern boundary)\nleft_lon::Float64: Minimum longitude (western boundary)\ntop_lat::Float64: Maximum latitude (northern boundary)\nright_lon::Float64: Maximum longitude (eastern boundary)\n\nExamples\n\nbbox = BBox(54.0, 9.0, 55.0, 10.0)  # lat_min, lon_min, lat_max, lon_max\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.Position","page":"API Reference","title":"OpenStreetMapIO.Position","text":"Position\n\nRepresents a geographic coordinate with latitude and longitude.\n\nFields\n\nlat::Float64: Latitude in decimal degrees (-90 to 90)\nlon::Float64: Longitude in decimal degrees (-180 to 180)\n\nExamples\n\ncoord = Position(54.2619665, 9.9854149)\n\n\n\n\n\n","category":"type"},{"location":"api/#OpenStreetMapIO.Info","page":"API Reference","title":"OpenStreetMapIO.Info","text":"Info\n\nOptional metadata for OSM elements (nodes, ways, relations). Contains versioning and attribution information.\n\nFields\n\nversion::Union{Int32,Nothing}: Version number of this element\ntimestamp::Union{DateTime,Nothing}: Last modification timestamp\nchangeset::Union{Int64,Nothing}: Changeset ID that created/modified this version\nuid::Union{Int32,Nothing}: User ID of the modifier\nuser::Union{String,Nothing}: Username of the modifier\nvisible::Union{Bool,Nothing}: Visibility flag (for historical data)\n\nExamples\n\ninfo = Info(1, DateTime(2023, 1, 1), 12345, 100, \"mapper\", true)\ninfo_minimal = Info(nothing, nothing, nothing, nothing, nothing, nothing)\n\n\n\n\n\n","category":"type"},{"location":"api/#Examples","page":"API Reference","title":"Examples","text":"","category":"section"},{"location":"api/#Basic-Usage","page":"API Reference","title":"Basic Usage","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"using OpenStreetMapIO\n\n# Read OSM PBF data (supports all compression formats)\nosmdata = readpbf(\"map.pbf\")\n\n# Query by bounding box\nbbox = BBox(53.45, 9.95, 53.55, 10.05)\nosmdata = queryoverpass(bbox)\n\n# Query by center point and radius\ncenter = Position(53.55, 9.99)\nosmdata = queryoverpass(center, 1000)  # 1km radius\n\n# Access node data\nfor (id, node) in osmdata.nodes\n    println(\"Node $id at ($(node.position.lat), $(node.position.lon))\")\n    if node.info !== nothing\n        println(\"  Version: $(node.info.version), User: $(node.info.user)\")\n    end\nend\n\n# Access way data with LocationsOnWays\nfor (id, way) in osmdata.ways\n    if way.positions !== nothing\n        println(\"Way $id has embedded coordinates\")\n    end\nend","category":"page"},{"location":"api/#Callback-Filtering","page":"API Reference","title":"Callback Filtering","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"# Filter restaurants\nfunction keep_restaurants(node)\n    if node.tags !== nothing &&\n       haskey(node.tags, \"amenity\") &&\n       node.tags[\"amenity\"] == \"restaurant\"\n        return node\n    end\n    return nothing\nend\n\nosmdata = readpbf(\"map.pbf\", node_callback=keep_restaurants)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides comprehensive examples showing how to use OpenStreetMapIO.jl for various tasks.","category":"page"},{"location":"examples/#Basic-File-Reading","page":"Examples","title":"Basic File Reading","text":"","category":"section"},{"location":"examples/#Reading-PBF-Files","page":"Examples","title":"Reading PBF Files","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OpenStreetMapIO\n\n# Read a PBF file\nosmdata = readpbf(\"map.pbf\")\n\n# Explore the data\nprintln(\"Dataset contains:\")\nprintln(\"  $(length(osmdata.nodes)) nodes\")\nprintln(\"  $(length(osmdata.ways)) ways\")\nprintln(\"  $(length(osmdata.relations)) relations\")\n\n# Check metadata\nif haskey(osmdata.meta, \"bbox\")\n    bbox = osmdata.meta[\"bbox\"]\n    println(\"Bounding box: $bbox\")\nend","category":"page"},{"location":"examples/#Reading-XML-Files","page":"Examples","title":"Reading XML Files","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Read an XML file (same interface as PBF)\nosmdata = readosm(\"map.osm\")\n\n# Data structure is identical\nprintln(\"Loaded $(length(osmdata.nodes)) nodes from XML\")","category":"page"},{"location":"examples/#Querying-from-Overpass","page":"Examples","title":"Querying from Overpass","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Query data for a specific area\nbbox = BBox(53.45, 9.95, 53.55, 10.05)\nosmdata = queryoverpass(bbox)\n\n# Query around a specific point\ncenter = Position(53.55, 9.99)\nosmdata = queryoverpass(center, 2000)  # 2km radius","category":"page"},{"location":"examples/#Working-with-Metadata","page":"Examples","title":"Working with Metadata","text":"","category":"section"},{"location":"examples/#Accessing-Element-Information","page":"Examples","title":"Accessing Element Information","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Read file with element metadata\nosmdata = readpbf(\"map.pbf\")\n\n# Access version information\nfor (id, node) in osmdata.nodes\n    if node.info !== nothing\n        println(\"Node $id:\")\n        println(\"  Version: $(node.info.version)\")\n        println(\"  Timestamp: $(node.info.timestamp)\")\n        println(\"  Changeset: $(node.info.changeset)\")\n        if node.info.user !== nothing\n            println(\"  User: $(node.info.user)\")\n        end\n    end\nend","category":"page"},{"location":"examples/#Working-with-LocationsOnWays","page":"Examples","title":"Working with LocationsOnWays","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Some PBF files include embedded coordinates in ways\nosmdata = readpbf(\"map.pbf\")\n\nfor (id, way) in osmdata.ways\n    if way.positions !== nothing\n        # Way has embedded node coordinates\n        println(\"Way $id with embedded coordinates:\")\n        for (i, pos) in enumerate(way.positions)\n            println(\"  Node $(way.refs[i]) at ($(pos.lat), $(pos.lon))\")\n        end\n    end\nend","category":"page"},{"location":"examples/#Data-Filtering-and-Processing","page":"Examples","title":"Data Filtering and Processing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following examples, we will demonstrate the functionality of the package.","category":"page"},{"location":"examples/#Filtering-by-Tags","page":"Examples","title":"Filtering by Tags","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Find all restaurants with specific cuisine\nfunction keep_italian_restaurants(node)\n    if node.tags !== nothing &&\n       haskey(node.tags, \"amenity\") &&\n       node.tags[\"amenity\"] == \"restaurant\" &&\n       haskey(node.tags, \"cuisine\") &&\n       node.tags[\"cuisine\"] == \"italian\"\n        return node\n    end\n    return nothing\nend\n\nitalian_restaurants = readpbf(\"map.pbf\", node_callback=keep_italian_restaurants)\nprintln(\"Found $(length(italian_restaurants.nodes)) Italian restaurants\")\n\n# Find all highways\nfunction keep_highways(way)\n    if way.tags !== nothing && haskey(way.tags, \"highway\")\n        return way\n    end\n    return nothing\nend\n\nhighways = readpbf(\"map.pbf\", way_callback=keep_highways)\nprintln(\"Found $(length(highways.ways)) highways\")\n\n# Find all bus routes\nfunction keep_bus_routes(relation)\n    if relation.tags !== nothing &&\n       haskey(relation.tags, \"route\") &&\n       relation.tags[\"route\"] == \"bus\"\n        return relation\n    end\n    return nothing\nend\n\n# Apply all filters\nosmdata = readpbf(\"map.pbf\",\n    node_callback=keep_italian_restaurants,\n    way_callback=keep_highways,\n    relation_callback=keep_bus_routes\n)\n\nprintln(\"Filtered dataset:\")\nprintln(\"  $(length(osmdata.nodes)) Italian restaurants\")\nprintln(\"  $(length(osmdata.ways)) highways\")\nprintln(\"  $(length(osmdata.relations)) bus routes\")","category":"page"},{"location":"examples/#Adding-Custom-Tags","page":"Examples","title":"Adding Custom Tags","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Add processing metadata to all nodes\nfunction add_processing_info(node)\n    new_tags = node.tags === nothing ? Dict{String,String}() : copy(node.tags)\n    new_tags[\"processed_by\"] = \"OpenStreetMapIO.jl\"\n    new_tags[\"processed_at\"] = string(now())\n    return Node(node.position, new_tags, node.info)\nend\n\nprocessed_data = readpbf(\"map.pbf\", node_callback=add_processing_info)","category":"page"},{"location":"examples/#Finding-Points-of-Interest","page":"Examples","title":"Finding Points of Interest","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Find all points of interest in an area\nfunction keep_pois(node)\n    if node.tags !== nothing\n        # Check for common POI tags\n        poi_tags = [\"amenity\", \"tourism\", \"shop\", \"leisure\", \"historic\"]\n        for tag in poi_tags\n            if haskey(node.tags, tag)\n                return node\n            end\n        end\n    end\n    return nothing\nend\n\npois = readpbf(\"map.pbf\", node_callback=keep_pois)\nprintln(\"Found $(length(pois.nodes)) points of interest\")\n\n# Analyze POI types\npoi_types = Dict{String,Int}()\nfor (id, node) in pois.nodes\n    if node.tags !== nothing\n        for (key, value) in node.tags\n            if key in [\"amenity\", \"tourism\", \"shop\", \"leisure\", \"historic\"]\n                poi_types[value] = get(poi_types, value, 0) + 1\n            end\n        end\n    end\nend\n\n# Show most common POI types\nsorted_types = sort(collect(poi_types), by=x->x[2], rev=true)\nfor (type, count) in sorted_types[1:10]\n    println(\"$type: $count\")\nend","category":"page"},{"location":"examples/#Memory-Efficient-Processing","page":"Examples","title":"Memory-Efficient Processing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Process data without storing everything in memory\nfunction analyze_without_storage(filename)\n    restaurant_count = 0\n    highway_count = 0\n\n    function count_restaurants(node)\n        if node.tags !== nothing &&\n           haskey(node.tags, \"amenity\") &&\n           node.tags[\"amenity\"] == \"restaurant\"\n            restaurant_count += 1\n        end\n        return nothing  # Don't store the node\n    end\n\n    function count_highways(way)\n        if way.tags !== nothing && haskey(way.tags, \"highway\")\n            highway_count += 1\n        end\n        return nothing  # Don't store the way\n    end\n\n    readpbf(filename,\n        node_callback=count_restaurants,\n        way_callback=count_highways\n    )\n\n    println(\"Found $restaurant_count restaurants and $highway_count highways\")\nend","category":"page"},{"location":"#OpenStreetMapIO.jl","page":"Home","title":"OpenStreetMapIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A comprehensive OpenStreetMap (OSM) data file reader for Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"File Format Support: Read OSM data from both PBF and XML formats\nOnline Data Access: Query OSM data directly from Overpass API\nCallback Support: Filter data during reading with custom callback functions","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/moviro-hub/OpenStreetMapIO.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpenStreetMapIO\n\n# Read OSM data from files\nosmdata = readpbf(\"map.pbf\")  # PBF format\nosmdata = readosm(\"map.osm\")  # XML format\n\n# Query data from Overpass API\nbbox = BBox(53.45, 9.95, 53.55, 10.05)\nosmdata = queryoverpass(bbox)\n\n# Filter data during reading\nfunction keep_restaurants(node)\n    if node.tags !== nothing && haskey(node.tags, \"amenity\") && node.tags[\"amenity\"] == \"restaurant\"\n        return node\n    end\n    return nothing\nend\n\nosmdata = readpbf(\"map.pbf\", node_callback=keep_restaurants)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is licensed under the MIT License. See LICENSE.md for details.","category":"page"}]
}
